{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"ver",
				"versionString"
			],
			[
				"deb",
				"debugLog"
			],
			[
				"comm",
				"commandString"
			],
			[
				"debug",
				"debugLogB"
			],
			[
				"seri",
				"serialPort"
			],
			[
				"tabl",
				"tableDieEvent"
			],
			[
				"offsetMil",
				"offsetMilliseconds"
			],
			[
				"UTC",
				"UTCMilliseconds"
			],
			[
				"off",
				"offsetMilliseconds"
			],
			[
				"mic",
				"micros"
			],
			[
				"di",
				"dieSize"
			]
		]
	},
	"buffers":
	[
		{
			"file": "CloudApp_CrispyHW_Agent.nut",
			"settings":
			{
				"buffer_size": 6783,
				"line_ending": "Unix"
			}
		},
		{
			"file": "ThingApp_CrispyHW_Device.nut",
			"settings":
			{
				"buffer_size": 6689,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 67.0,
		"selected_items":
		[
			[
				"inspac",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 146.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": true,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/duppy/Documents/GitHub/crispyhardware/CrispyHardware-WebApp/index.html",
		"/Users/duppy/Documents/GitHub/Crispy_ThingApp/electricimp/crispy-thingstream-name-server-allStreamInfoByUuid-export.json",
		"/Users/duppy/Documents/GitHub/Crispy_ThingApp/electricimp/crispy-thingstream-name-server-allThingInfoByUuid-export.json",
		"/Users/duppy/Documents/GitHub/Locketo_ThingApp/electricimp/CloudApp_Locketo_Proto_Agent.nut",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Soda_Agent.nut",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/ThingApp_Imp_Soda_Device.nut",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/Sample_MMA8452Q_Device.nut",
		"/Users/duppy/Dropbox/TechShop/Cloud Dice/3Dprint/case0bin.jsCAD.js",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Dice_MMA8452Q_Agent.nut",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/ThingApp_Imp_Dice_MMA8452Q_Device.nut",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/electricdice-all-metadata-export.json",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Dice_rules.json",
		"/Users/duppy/Documents/GitHub/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Dice_MMA8452Q.Agent..nut",
		"/C/Users/duppy/Dropbox/Apps/site44/www.interfacearts.com/fireview/index.html",
		"/C/Users/duppy/Dropbox/Apps/site44/www.interfacearts.com/index.html",
		"/C/Users/duppy/Dropbox/Apps/site44/fireview.interfacearts.com/index (Duppy Proctor's conflicted copy 2013-05-03).html",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/d3.js.index.html",
		"/C/Users/duppy/Dropbox/TechShop/CoCo/TIworkspace/CoCo-ThingApp-DVT/CoCo BlueGiga/CoCo.bgs",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/electricdice-fb-d3.js",
		"/C/Users/duppy/Documents/GitHub/senstream-firmware/mobilemuse_arduino/mobilemuse_arduino.ino",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/User/Preferences.sublime-settings",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/Squirrel/Squirrel.tmLanguage",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/ThingApp/ElectricDice-ThingApp-Proxy-Processing/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Dice_MMA8452Q.Agent..nut",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/ThingApp/ElectricDice-ThingApp-Proxy-Processing/ElectricDice_ThingApp/ElectricImp_Dice/ThingApp_Imp_Dice_MMA8452Q_Device.nut",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/User/Plain text.sublime-settings",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/Default/Preferences.sublime-settings",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/ex-bootstratp.html"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"putStreamValue",
			"agent.send",
			"putStreamValue",
			"/* crispy hardware\n/* ThingApp Device Electric Imp Squirrel code */\n\n/////////////////////////////////////////////////\n// global constants and variables\n\n// generic\nconst versionString = \"crispy hardware v00.01.2014-03-13a\"\nconst logIndent   = \".........>.........>.........>.........>.........>.........>.........>.........>.........>.........>.........>\"\nimpeeID <- hardware.getimpeeid() // cache the impeeID FIXME: is this necessary for speed?\noffsetMilliseconds <- 0 // set later to milliseconds % 1000 when time() rolls over //FIXME: need a better timesync solution here\nconst sleepforTimeout = 60 // seconds idle before decrementing idleCount\nconst idleCountMax = 240 //3 // number sleepforTimeout periods before server.sleepfor()\nconst sleepforDuration = 36000//300 // seconds to stay in deep sleep (wakeup is a reboot)\nidleCount <- idleCountMax // Current count of idleCountMax timer\n\nactive <- false\n\n// configuration variables\nvBatt       <- hardware.pin2\nserialPort  <- hardware.uart57\nserialPortB  <- hardware.uart1289\n\n// app specific globals\n\n///////////////////////////////////////////////\n//define functions\n\n// start with generic functions\nfunction timestamp() {\n    local t, m\n    t = time()\n    m = hardware.millis()\n    return format(\"%010u%03u\", t, (m - offsetMilliseconds) % 1000)\n        // return milliseconds since Unix epoch \n}\n\nfunction checkActivity() {\n// checkActivity re-schedules itself every sleepforTimeout\n// FIXME: checkActivity should be more generic\n    server.log(\"checkActivity() every \" + sleepforTimeout + \" secs.\")\n    // let the agent know we are still alive\n    agent.send(\n        \"event\",\n        {\n            \"healthStatus\" : {\n                \"keepAlive\": idleCount,\n                // \"vBatt\": getVBatt(),\n                \"t\": timestamp(),\n            }\n        }\n    )\n\n    server.log(\"idle : \" + idleCount)\n\n    if (active) {\n        active = false\n        idleCount = idleCountMax // restart idle count down\n    } else {\n        if (idleCount == 0) {\n            idleCount = idleCountMax\n            led1.write(0)\n            server.log(\"No activity for \" + sleepforTimeout * idleCountMax + \" to \" + sleepforTimeout * (idleCountMax + 1) + \" secs.\\r\\nGoing to deepsleep for \" + (sleepforDuration / 60.0) + \" minutes.\")\n            //\n            // do app specific shutdown stuff here\n            //\n            // serialPort.write(\"impsleep\")\n            // serialPort.flush()\n            imp.sleep(0.333)\n\n            // keyPin.configure(DIGITAL_IN_WAKEUP, readKey)\n            // led1.configure(DIGITAL_IN_WAKEUP, wakeup)\n            imp.sleep(0.333)\n            imp.onidle(function() { server.sleepfor(sleepforDuration) })  // go to deepsleep if no activity for sleepforTimeout\n        } else {\n            idleCount -= 1\n            imp.setpowersave(true) // FIXME: currently uneccessary, we are always in 5mA powersave mode\n        }\n    }\n    imp.wakeup(sleepforTimeout, checkActivity) // re-schedule self\n} // checkActivity\n\nfunction processCommand(commandString, port) {\n    local message = {}\n    \n    message[port] <- commandString    \n    agent.send(\n        \"event\",\n         message\n    )\n}\n\nfunction readSerialPort() {\n    // Get first byte\n    local timeKey = timestamp()\n    local b = serialPort.read()\n\n    // server.log(\"activity on serial port\")\n    active = true // signal activity to keep imp awake\n    while (b != -1) {\n        // process byte\n        if (b != '\\r') {   \n            serialString.writen(b, 'b')\n            // server.log(\"b = \" + b + \", serialString.len() = \" + serialString.len())\n            if ( (serialString.tell() >= serialStringMaxLength)\n            ||   (b == '\\n') ) {\n                local string = format(\"%s\", \"\" + serialString)\n                processCommand(string, \"debugLog\")\n                serialString.resize(0)\n            }\n        }\n        b = serialPort.read()\n    }\n}\n\nfunction readSerialPortB() {\n    // Get first byte\n    local timeKey = timestamp()\n    local b = serialPortB.read()\n\n    // server.log(\"activity on serial port\")\n    active = true // signal activity to keep imp awake\n    while (b != -1) {\n        // process byte\n        if (b != '\\r') {   \n            serialString.writen(b, 'b')\n            // server.log(\"b = \" + b + \", serialString.len() = \" + serialString.len())\n            if ( (serialString.tell() >= serialStringMaxLength)\n            ||   (b == '\\n') ) {\n                local string = format(\"%s\", \"\" + serialString)\n                processCommand(string, \"debugLogB\")\n                serialString.resize(0)\n            }\n        }\n        b = serialPortB.read()\n    }\n}\n\n////////////////////////////////////////////////////////\n// first code starts here\n\nimp.setpowersave(true) // start in low power mode.\n/******* https://electricimp.com/docs/api/imp/setpowersave/\nPower-save mode is disabled by default; this means the WiFi radio receiver is enabled constantly. This results in the lowest latency for data transfers, but a high power drain (~60-80mA at 3.3v).\n\nEnabling power-save mode drops this down to < 5mA when the radio is idle (i.e., between transactions with the server). The down-side is added latency on received data transfers, which can be as high as 250ms.\n*******/\n\n// Send status to know we are alive\nserver.log(\"BOOTING  \" + versionString + \" \" + hardware.getimpeeid() + \"/\" + imp.getmacaddress())\nserver.log(\"imp software version : \" + imp.getsoftwareversion())\nserver.log(\"connected to WiFi : \" + imp.getbssid())\n\n// BUGBUG: below needed until newer firmware!?  See http://forums.electricimp.com/discussion/comment/4875#Comment_2714\n// imp.enableblinkup(true)\n\nlocal lastUTCSeconds = time()\nwhile(lastUTCSeconds == time()) {\n}\noffsetMilliseconds = hardware.millis() % 1000\n// FIXME: should re-calibrate offset periodically, not just on boot\nserver.log(\"offsetMilliseconds = \" + offsetMilliseconds)\n\nserialStringMaxLength <- 80\nserialString <- blob(0)\nseriialLastTime <- timestamp()\nserialPort.configure(230400, 8, PARITY_NONE, 1, NO_CTSRTS, readSerialPort)\nserialPortB.configure(230400, 8, PARITY_NONE, 1, NO_CTSRTS, readSerialPortB)\n\nagent.send(\n    \"event\",\n     {\n        \"debugLog\" : \"[BOOTING Electric Imp Log A] \" + versionString,\n     }\n)\nagent.send(\n    \"event\",\n     {\n        \"debugLogB\" : \"[BOOTING Electric Imp Log B] \" + versionString,\n     }\n)\n\ncheckActivity() // kickstart checkActivity, this re-schedules itself every sleepforTimeout seconds\n// FIXME: checkActivity waits from sleepforTimeout to sleepforTimeout*2.  Make this more constant.\n\n// No more code to execute so we'll sleep until an interrupts from serial or pin 1\n// End of code.\n\n// crispy hardware\n// ThingApp Imp Device Squirrel code */\n",
			"19200",
			"sleepforTimeout",
			"streaminfo",
			"debugLog",
			"refBigDataByName",
			"gLog",
			"serialPortB",
			"readSerialPort",
			"processCommand",
			"alPort",
			"serialPort",
			"processCommand",
			"readSerialPort",
			"ssid",
			"error",
			"server.log(",
			"server.se",
			"log(",
			"log",
			"passcode",
			"Locketo-impv00-hDzxieGblkLa",
			"locketo-",
			"IA_Locketo",
			"passcode",
			"hDzxieGblkLa",
			"Locketo-impv00",
			"impv00",
			"refAllSessionsByStreamUuid",
			"thingstream-name-se",
			"putStreamValue",
			"refAllSessionsByName",
			"refAllSessionsByStreamUuid",
			"Locketo",
			"locketo",
			"Locketo",
			"locketo",
			"Locketo",
			"passcode",
			"ConnectedHD",
			"Proto",
			"ConnectedHD",
			"ealthStatus",
			"Passcode",
			"redrawPasscodeList",
			"Passcode",
			"passcode",
			"Passcode",
			"passcode",
			"Passcode",
			"passcode",
			"Passcode",
			"passcode",
			"Passcode",
			"passcode",
			"100",
			"300",
			"50",
			"128",
			"350",
			"getFaceValueFromAccelData",
			"readAccelData",
			"getFaceValueFromAccelData",
			"CTRL_REG4",
			"CTRL_REG1",
			"CTRL_REG2",
			"server.log",
			"fbRoot",
			"server.log",
			"tsRoot",
			"fbUuid",
			"fbRoot",
			"log(",
			"[^.]log\\(",
			"[^.]error\\(",
			"[~.]error\\(",
			"^error\\(",
			"^error(",
			" error(",
			" log(",
			", [0-9]+\\)",
			"log(",
			"impAgentURLRoot",
			"agent.send",
			"send",
			"firebaseURLParamsTable",
			"firebaseURLRoot",
			"firebaseURLParamsString",
			"firebaseUUID",
			"tableDieEvent",
			"fakeMillis",
			"mapImpeeID_DieID",
			"firebaseURLParamsTable",
			"firebaseURLParamsString",
			"uuid",
			"fbUuidPrefix",
			"firebaseUUID",
			"firebaseURLRoot",
			"auth",
			"emRthqxr7UVV6Jw4SeEI9G65GA0CUXpfVN3eBoGO",
			"firebaseURLParamsTable",
			"firebaseURLParamsString",
			"ubidots",
			"getVBatt",
			"firebaseURLParamsString",
			"firebaseURLParamsTable",
			"readSequentialRegs",
			"uuid",
			"checkActivity",
			"initMMA8452Q",
			"fakeMillis",
			"agent.send",
			"getVBatt",
			"complete",
			"timestamp",
			"send",
			"timestamp",
			"firebaseUUID",
			"timestamp",
			"offsetMilliseconds",
			"agent",
			"date",
			"millis",
			"ubi",
			"offsetMilliseconds"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			" server.error(",
			" server.log(",
			"\\)"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "CloudApp_CrispyHW_Agent.nut",
					"settings":
					{
						"buffer_size": 6783,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								6783
							]
						],
						"settings":
						{
							"syntax": "Packages/Squirrel/Squirrel.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "ThingApp_CrispyHW_Device.nut",
					"settings":
					{
						"buffer_size": 6689,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								6689
							]
						],
						"settings":
						{
							"syntax": "Packages/Squirrel/Squirrel.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2787.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.510461157536,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.unsaved_changes":
	{
		"height": 404.0
	},
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"/C/Users/duppy/Documents/GitHub/senstream-firmware/Schematics/schematics-senstream.sublime-project"
			]
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 297.0,
	"status_bar_visible": true
}
